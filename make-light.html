<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make Light </title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --text-primary: #f5f5f5;
            --text-secondary: #888;
            --accent: #ffcc00;
            --accent-dim: #665200;
            --border: #2a2a2a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 100vw;
            min-height: 100vh;
            position: relative;
        }

        /* Home Screen */
        .home-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            position: relative;
        }

        .home-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 204, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 204, 0, 0.02) 0%, transparent 50%);
            pointer-events: none;
        }

        .logo {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2.5rem, 8vw, 6rem);
            font-weight: 300;
            letter-spacing: 0.05em;
            margin-bottom: 4rem;
            text-align: center;
            position: relative;
            animation: fadeInDown 1s ease-out;
        }

        .make-light-btn {
            font-family: 'Space Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            padding: 1.5rem 3rem;
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            animation: fadeInUp 1s ease-out 0.3s both;
        }

        .make-light-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--accent);
            transition: left 0.3s ease;
            z-index: -1;
        }

        .make-light-btn:hover::before {
            left: 0;
        }

        .make-light-btn:hover {
            color: var(--bg-primary);
        }

        .song-list-btn {
            margin-top: 2rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            padding: 0.75rem 2rem;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            animation: fadeInUp 1s ease-out 0.5s both;
        }

        .song-list-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        /* Create Screen */
        .create-screen {
            display: none;
            min-height: 100vh;
            padding: 2rem;
        }

        .create-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .back-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 0.5rem 0;
            margin-bottom: 2rem;
            transition: color 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .back-btn:hover {
            color: var(--text-primary);
        }

        .input-container {
            max-width: 600px;
            margin: 4rem auto;
        }

        .input-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .song-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 0;
            padding: 1.5rem;
            font-family: 'Space Mono', monospace;
            font-size: 1.1rem;
            color: var(--text-primary);
            outline: none;
            transition: border-color 0.3s ease;
        }

        .song-input:focus {
            border-color: var(--accent);
        }

        .questions-container {
            margin-top: 3rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .question {
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeInUp 0.5s ease forwards;
        }

        .question:nth-child(1) { animation-delay: 0.1s; }
        .question:nth-child(2) { animation-delay: 0.2s; }
        .question:nth-child(3) { animation-delay: 0.3s; }

        .question-text {
            font-size: 0.95rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .options {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .option-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .option-btn.selected {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .skip-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 0.5rem;
        }

        .generate-btn {
            display: block;
            margin: 3rem auto;
            padding: 1.25rem 3rem;
            background: var(--accent);
            border: none;
            color: var(--bg-primary);
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .generate-btn:hover {
            background: var(--accent-dim);
        }

        .generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Light Preview */
        .light-preview {
            display: none;
            max-width: 800px;
            margin: 4rem auto;
            text-align: center;
        }

        .light-preview.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .light-message {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            font-style: italic;
        }

        .dmx-zones {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 3rem 0;
            padding: 2rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .zone {
            aspect-ratio: 1;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .zone::before {
            content: '';
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .zone-label {
            position: relative;
            z-index: 1;
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .feedback-input {
            width: 100%;
            max-width: 600px;
            margin: 2rem auto;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 1rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            resize: vertical;
            min-height: 100px;
        }

        .save-btn, .refine-btn, .test-btn {
            padding: 1rem 2.5rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-btn {
            background: var(--accent);
            border: none;
            color: var(--bg-primary);
        }

        .refine-btn, .test-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        .save-btn:hover {
            background: var(--accent-dim);
        }

        .refine-btn:hover, .test-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Song List Screen */
        .songlist-screen {
            display: none;
            min-height: 100vh;
            padding: 2rem;
        }

        .songlist-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .songlist-header {
            max-width: 800px;
            margin: 0 auto 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .songlist-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            font-weight: 300;
        }

        .songs-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .song-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .song-item:hover {
            border-color: var(--accent);
        }

        .song-item.active {
            border-color: var(--accent);
            background: rgba(255, 204, 0, 0.05);
        }

        .song-title {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .song-meta {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .song-structure {
            display: none;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        .song-item.active .song-structure {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            animation: fadeIn 0.3s ease;
        }

        .structure-part {
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            font-size: 0.8rem;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .structure-part.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .structure-part:hover {
            border-color: var(--accent);
        }

        /* Loading & Status */
        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .status-message {
            max-width: 600px;
            margin: 2rem auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent);
            font-size: 0.9rem;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Settings Panel */
        .settings-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .settings-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .settings-panel {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            padding: 2rem;
            z-index: 999;
            overflow-y: auto;
        }

        .settings-panel.active {
            display: block;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }

        .settings-group {
            margin-bottom: 2rem;
        }

        .settings-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .settings-group input {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            padding: 0.75rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Home Screen -->
        <div class="home-screen active" id="homeScreen">
            <h1 class="logo">Make Light</h1>
            <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 3rem; text-align: center; max-width: 400px;">
                AI-Powered DMX Control<br>
                <span style="font-size: 0.8rem;">Claude ‚Ä¢ GPT ‚Ä¢ Gemini ‚Ä¢ Ollama</span>
            </p>
            <button class="make-light-btn" onclick="showCreateScreen()">Make Light</button>
            <button class="song-list-btn" onclick="showSongList()">Song Library</button>
        </div>

        <!-- Create Screen -->
        <div class="create-screen" id="createScreen">
            <button class="back-btn" onclick="showHomeScreen()">‚Üê Back</button>
            
            <div class="input-container">
                <div class="input-label">What do you want to make light for?</div>
                <input 
                    type="text" 
                    class="song-input" 
                    id="songInput"
                    placeholder="e.g. Human - Rag & Bone Man"
                    onkeypress="if(event.key === 'Enter') generateQuestions()"
                >
            </div>

            <div class="questions-container" id="questionsContainer"></div>

            <div class="light-preview" id="lightPreview">
                <div class="light-message">...and there was light ‚Äî try it out</div>
                <div class="dmx-zones" id="dmxZones"></div>
                <div class="action-buttons">
                    <button class="test-btn" onclick="testLight()">Test Light</button>
                    <button class="save-btn" onclick="saveLight()">Save</button>
                </div>
                <textarea class="feedback-input" id="feedbackInput" placeholder="How should I adjust the light?"></textarea>
                <button class="refine-btn" onclick="refineLight()">Refine</button>
            </div>
        </div>

        <!-- Song List Screen -->
        <div class="songlist-screen" id="songlistScreen">
            <div class="songlist-header">
                <h2 class="songlist-title">Setlist</h2>
                <button class="back-btn" onclick="showHomeScreen()">‚Üê Back</button>
            </div>
            <div class="songs-container" id="songsContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">üí°</div>
                    <p>No saved songs yet</p>
                    <p style="font-size: 0.85rem; margin-top: 0.5rem;">Create your first light design</p>
                </div>
            </div>
        </div>

        <!-- Settings -->
        <button class="settings-btn" onclick="toggleSettings()">‚öô</button>
        <div class="settings-panel" id="settingsPanel">
            <h3 style="margin-bottom: 2rem;">Settings</h3>
            
            <div class="settings-group">
                <label>AI Provider</label>
                <select id="aiProviderInput" onchange="updateAIModelOptions()">
                    <option value="claude">Claude (Anthropic)</option>
                    <option value="openai">OpenAI GPT</option>
                    <option value="gemini">Google Gemini (Gratis!)</option>
                    <option value="ollama">Ollama (Local)</option>
                </select>
            </div>

            <div class="settings-group">
                <label>AI Model</label>
                <select id="aiModelInput">
                    <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                </select>
            </div>

            <div class="settings-group">
                <label id="apiKeyLabel">Claude API Key</label>
                <input type="password" id="apiKeyInput" placeholder="sk-ant-...">
                <small style="color: var(--text-secondary); font-size: 0.75rem; margin-top: 0.25rem; display: block;">
                    <span id="apiKeyHelp">Get key: console.anthropic.com</span>
                </small>
            </div>

            <div class="settings-group">
                <label>ESP8266 IP Address</label>
                <input type="text" id="espIpInput" placeholder="192.168.1.100" value="192.168.1.100">
            </div>

            <div class="settings-group">
                <label>DMX Universe</label>
                <input type="number" id="dmxUniverseInput" value="1">
            </div>

            <button class="save-btn" style="width: 100%; margin-top: 1rem;" onclick="saveSettings()">Save Settings</button>
            
            <button onclick="testAIConnection()" style="width: 100%; margin-top: 0.5rem; background: #333; color: #fff; padding: 0.75rem; border: 1px solid #555; cursor: pointer; font-family: monospace;">
                üß™ Test AI Connection
            </button>
            <div id="testResult" style="margin-top: 1rem; padding: 0.75rem; background: #000; border: 1px solid #333; font-size: 0.8rem; display: none;"></div>
        </div>
    </div>

    <script>
        // App State
        let currentSong = null;
        let currentLight = null;
        let savedSongs = JSON.parse(localStorage.getItem('savedSongs') || '[]');
        let settings = JSON.parse(localStorage.getItem('settings') || '{}');
        let dmxConfig = null;
        let activeSongId = null;
        let activePartIndex = 0;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            loadDMXConfig();
            renderSongList();
        });

        // Load DMX Configuration
        async function loadDMXConfig() {
            try {
                const response = await fetch('dmx-config.json');
                dmxConfig = await response.json();
                console.log('DMX Config loaded:', dmxConfig);
            } catch (error) {
                console.warn('Could not load DMX config, using defaults');
                dmxConfig = getDefaultConfig();
            }
        }

        function getDefaultConfig() {
            return {
                dmx_config: {
                    zones: {
                        'front_right': { fixtures: [{ start_channel: 1, channel_map: { red: 1, green: 2, blue: 3, dimmer: 4, strobe: 5 } }] },
                        'front_left': { fixtures: [{ start_channel: 8, channel_map: { red: 8, green: 9, blue: 10, dimmer: 11, strobe: 12 } }] },
                        'mid_right': { fixtures: [{ start_channel: 15, channel_map: { red: 15, green: 16, blue: 17, dimmer: 18, strobe: 19 } }] },
                        'mid_left': { fixtures: [{ start_channel: 22, channel_map: { red: 22, green: 23, blue: 24, dimmer: 25, strobe: 26 } }] },
                        'back_right': { fixtures: [{ start_channel: 29, channel_map: { red: 29, green: 30, blue: 31, dimmer: 32, strobe: 33 } }] },
                        'back_left': { fixtures: [{ start_channel: 36, channel_map: { red: 36, green: 37, blue: 38, dimmer: 39, strobe: 40 } }] }
                    }
                }
            };
        }

        // Navigation
        function showHomeScreen() {
            document.querySelectorAll('.home-screen, .create-screen, .songlist-screen').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('homeScreen').classList.add('active');
        }

        function showCreateScreen() {
            document.querySelectorAll('.home-screen, .create-screen, .songlist-screen').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('createScreen').classList.add('active');
            document.getElementById('songInput').focus();
        }

        function showSongList() {
            document.querySelectorAll('.home-screen, .create-screen, .songlist-screen').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('songlistScreen').classList.add('active');
            renderSongList();
        }

        // Settings
        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('active');
        }

        function loadSettings() {
            if (settings.apiKey) document.getElementById('apiKeyInput').value = settings.apiKey;
            if (settings.espIp) document.getElementById('espIpInput').value = settings.espIp;
            if (settings.dmxUniverse) document.getElementById('dmxUniverseInput').value = settings.dmxUniverse;
            if (settings.aiProvider) {
                document.getElementById('aiProviderInput').value = settings.aiProvider;
                updateAIModelOptions();
                if (settings.aiModel) document.getElementById('aiModelInput').value = settings.aiModel;
            }
        }

        function saveSettings() {
            settings = {
                apiKey: document.getElementById('apiKeyInput').value,
                espIp: document.getElementById('espIpInput').value,
                dmxUniverse: parseInt(document.getElementById('dmxUniverseInput').value),
                aiProvider: document.getElementById('aiProviderInput').value,
                aiModel: document.getElementById('aiModelInput').value
            };
            localStorage.setItem('settings', JSON.stringify(settings));
            document.getElementById('settingsPanel').classList.remove('active');
            showStatus('Settings saved');
        }

        // Test AI Connection
        async function testAIConnection() {
            const resultDiv = document.getElementById('testResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'üîÑ Testing AI connection...';
            
            const provider = settings.aiProvider || 'claude';
            const apiKey = settings.apiKey;
            
            if (!apiKey && provider !== 'ollama') {
                resultDiv.innerHTML = '‚ùå No API key set!';
                return;
            }
            
            // Special handling for Gemini - list available models first
            if (provider === 'gemini') {
                resultDiv.innerHTML = 'üîç Finding available Gemini models...';
                
                try {
                    const listResponse = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`
                    );
                    
                    if (!listResponse.ok) {
                        throw new Error(`Cannot list models: ${listResponse.status}`);
                    }
                    
                    const listData = await listResponse.json();
                    const availableModels = listData.models
                        .filter(m => m.supportedGenerationMethods && m.supportedGenerationMethods.includes('generateContent'))
                        .map(m => m.name.replace('models/', ''));
                    
                    console.log('‚úÖ Available Gemini models:', availableModels);
                    
                    resultDiv.innerHTML = `üìã Found ${availableModels.length} models:<br><br>` + 
                        availableModels.map(m => `‚Ä¢ ${m}`).join('<br>') + 
                        '<br><br>üîÑ Testing first available model...';
                    
                    // Try first available model
                    if (availableModels.length > 0) {
                        const testModel = availableModels[0];
                        settings.aiModel = testModel;
                        
                        const testPrompt = 'Say "Hello" in JSON format: {"message": "Hello"}';
                        const response = await callAI(testPrompt);
                        
                        resultDiv.innerHTML = `‚úÖ SUCCESS!<br><br>` +
                            `Best model for you: <strong>${testModel}</strong><br><br>` +
                            `Response: ${response.substring(0, 100)}...<br><br>` +
                            `<em>This model has been saved. Click Save Settings to keep it.</em>`;
                        
                        // Update dropdown to show the working model
                        document.getElementById('aiModelInput').value = testModel;
                    } else {
                        resultDiv.innerHTML = '‚ùå No models available for your API key!<br><br>Please check API key or enable Generative Language API.';
                    }
                    
                } catch (error) {
                    resultDiv.innerHTML = `‚ùå FAILED!<br><br>Error: ${error.message}<br><br>Check Console (F12) for details.`;
                    console.error('Test failed:', error);
                }
                return;
            }
            
            // Original test for other providers
            try {
                resultDiv.innerHTML = `üîÑ Testing ${provider}...<br>Model: ${settings.aiModel}`;
                
                const testPrompt = 'Say "Hello" in JSON format: {"message": "Hello"}';
                const response = await callAI(testPrompt);
                
                resultDiv.innerHTML = `‚úÖ SUCCESS!<br><br>Provider: ${provider}<br>Response: ${response.substring(0, 100)}...`;
            } catch (error) {
                resultDiv.innerHTML = `‚ùå FAILED!<br><br>Provider: ${provider}<br>Error: ${error.message}<br><br>Check Console (F12) for details.`;
                console.error('Test failed:', error);
            }
        }

        // Update AI model dropdown based on selected provider
        function updateAIModelOptions() {
            const provider = document.getElementById('aiProviderInput').value;
            const modelSelect = document.getElementById('aiModelInput');
            const apiKeyLabel = document.getElementById('apiKeyLabel');
            const apiKeyHelp = document.getElementById('apiKeyHelp');
            const apiKeyInput = document.getElementById('apiKeyInput');
            
            // Update model options
            const modelOptions = {
                'claude': [
                    { value: 'claude-sonnet-4-20250514', label: 'Claude Sonnet 4' },
                    { value: 'claude-opus-4-20250514', label: 'Claude Opus 4' }
                ],
                'openai': [
                    { value: 'gpt-4o', label: 'GPT-4o' },
                    { value: 'gpt-4o-mini', label: 'GPT-4o Mini (Billig)' },
                    { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' }
                ],
                'gemini': [
                    { value: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash (Recommended)' },
                    { value: 'gemini-2.5-flash-latest', label: 'Gemini 2.5 Flash Latest' },
                    { value: 'gemini-1.5-flash-latest', label: 'Gemini 1.5 Flash' },
                    { value: 'gemini-1.5-pro-latest', label: 'Gemini 1.5 Pro' },
                    { value: 'gemini-1.0-pro', label: 'Gemini 1.0 Pro' }
                ],
                'ollama': [
                    { value: 'llama3.1', label: 'Llama 3.1' },
                    { value: 'mistral', label: 'Mistral' },
                    { value: 'codellama', label: 'Code Llama' }
                ]
            };
            
            modelSelect.innerHTML = modelOptions[provider].map(opt => 
                `<option value="${opt.value}">${opt.label}</option>`
            ).join('');
            
            // Update API key label and help text
            const keyInfo = {
                'claude': { label: 'Claude API Key', help: 'Get key: console.anthropic.com', placeholder: 'sk-ant-...' },
                'openai': { label: 'OpenAI API Key', help: 'Get key: platform.openai.com/api-keys', placeholder: 'sk-proj-...' },
                'gemini': { label: 'Gemini API Key (Gratis!)', help: 'Get key: aistudio.google.com/app/apikey', placeholder: 'AIza...' },
                'ollama': { label: 'Ollama (Local - No Key Needed)', help: 'Install: ollama.com/download', placeholder: 'No API key needed' }
            };
            
            apiKeyLabel.textContent = keyInfo[provider].label;
            apiKeyHelp.textContent = keyInfo[provider].help;
            apiKeyInput.placeholder = keyInfo[provider].placeholder;
            apiKeyInput.disabled = (provider === 'ollama');
        }

        // Universal AI calling functions
        async function callAI(prompt) {
            const provider = settings.aiProvider || 'claude';
            
            try {
                switch(provider) {
                    case 'claude':
                        return await callClaude(prompt);
                    case 'openai':
                        return await callOpenAI(prompt);
                    case 'gemini':
                        return await callGemini(prompt);
                    case 'ollama':
                        return await callOllama(prompt);
                    default:
                        throw new Error('Unknown AI provider');
                }
            } catch (error) {
                console.error(`AI call failed (${provider}):`, error);
                throw error;
            }
        }

        async function callClaude(prompt) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': settings.apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: settings.aiModel || 'claude-sonnet-4-20250514',
                    max_tokens: 2048,
                    messages: [{ role: 'user', content: prompt }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`Claude API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.content[0].text;
        }

        async function callOpenAI(prompt) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${settings.apiKey}`
                },
                body: JSON.stringify({
                    model: settings.aiModel || 'gpt-4o',
                    max_tokens: 2048,
                    messages: [{ role: 'user', content: prompt }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function callGemini(prompt) {
            const model = settings.aiModel || 'gemini-2.5-flash';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${settings.apiKey}`;
            
            console.log('üîç Gemini Debug:', {
                model: model,
                hasApiKey: !!settings.apiKey,
                apiKeyStart: settings.apiKey ? settings.apiKey.substring(0, 10) + '...' : 'MISSING',
                url: url.replace(settings.apiKey, 'KEY_HIDDEN')
            });
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ 
                            parts: [{ text: prompt }] 
                        }],
                        generationConfig: { 
                            maxOutputTokens: 2000,
                            temperature: 0.7
                        },
                        safetySettings: [
                            {
                                category: "HARM_CATEGORY_HARASSMENT",
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_HATE_SPEECH", 
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                                threshold: "BLOCK_NONE"
                            }
                        ]
                    })
                });
                
                console.log('üì° Gemini Response Status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Gemini Error Response:', errorText);
                    
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch {
                        errorData = { message: errorText };
                    }
                    
                    // Provide more helpful error messages
                    if (response.status === 400) {
                        throw new Error(`Gemini API 400: Invalid request. Check model name: ${model}. Available models: gemini-2.5-flash, gemini-1.5-flash-latest`);
                    } else if (response.status === 403) {
                        throw new Error(`Gemini API 403: Invalid API key or API not enabled. Get key: https://aistudio.google.com/app/apikey`);
                    } else if (response.status === 404) {
                        throw new Error(`Gemini API 404: Model "${model}" not found. Try: gemini-2.5-flash or use Test Connection to find available models.`);
                    } else {
                        throw new Error(`Gemini API error ${response.status}: ${JSON.stringify(errorData)}`);
                    }
                }
                
                const data = await response.json();
                console.log('‚úÖ Gemini Success:', data);
                
                // Check if response has candidates
                if (!data.candidates || data.candidates.length === 0) {
                    throw new Error('Gemini returned no candidates. Response may be blocked by safety filters.');
                }
                
                // Check if candidate has content
                const candidate = data.candidates[0];
                if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                    throw new Error('Gemini candidate has no content. Response may be empty.');
                }
                
                return candidate.content.parts[0].text;
            } catch (error) {
                console.error('üí• Gemini Call Failed:', error);
                throw error;
            }
        }

        async function callOllama(prompt) {
            const response = await fetch('http://localhost:11434/api/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: settings.aiModel || 'llama3.1',
                    prompt: prompt,
                    stream: false,
                    options: {
                        temperature: 0.7,
                        num_predict: 2000
                    }
                })
            });
            
            if (!response.ok) {
                throw new Error(`Ollama error: ${response.status}. Er Ollama k√∏rende?`);
            }
            
            const data = await response.json();
            return data.response;
        }

        // AI Integration
        async function generateQuestions() {
            const songInput = document.getElementById('songInput').value.trim();
            if (!songInput) return;

            if (!settings.apiKey && settings.aiProvider !== 'ollama') {
                showStatus('Please set your AI API key in settings');
                toggleSettings();
                return;
            }

            currentSong = { input: songInput };
            
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = '<div class="loading">Analyzing song...</div>';

            try {
                const prompt = 'Du er en kreativ lysdesigner. Brugeren vil lave lys til: "' + songInput + '"\n\n' +
                'Stil 2-3 korte, pr√¶cise sp√∏rgsm√•l for at forst√• den √∏nskede stemning og stil. Sp√∏rgsm√•lene skal have konkrete valgmuligheder.\n' +
                'Hvis du ikke genkender sangen, sp√∏rg ind til genren eller stemningen.\n\n' +
                'Returner KUN et JSON objekt i dette format:\n' +
                '{\n' +
                '  "songTitle": "sangtitel hvis kendt, ellers null",\n' +
                '  "questions": [\n' +
                '    {\n' +
                '      "text": "Sp√∏rgsm√•lstekst?",\n' +
                '      "options": ["Mulighed 1", "Mulighed 2", "Mulighed 3"]\n' +
                '    }\n' +
                '  ]\n' +
                '}';

                const content = await callAI(prompt);
                
                // Extract JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const questions = JSON.parse(jsonMatch[0]);
                    currentSong.title = questions.songTitle || songInput;
                    renderQuestions(questions.questions);
                }
            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error generating questions: ${error.message}`);
            }
        }

        function renderQuestions(questions) {
            const container = document.getElementById('questionsContainer');
            container.innerHTML = questions.map((q, index) => `
                <div class="question">
                    <div class="question-text">${q.text}</div>
                    <div class="options">
                        ${q.options.map(opt => `
                            <button class="option-btn" onclick="selectOption(${index}, '${opt}')">${opt}</button>
                        `).join('')}
                    </div>
                    <button class="skip-btn" onclick="skipQuestion(${index})">Skip</button>
                </div>
            `).join('');
            
            container.innerHTML += '<button class="generate-btn" onclick="generateLight()">Generate Light</button>';
        }

        function selectOption(questionIndex, option) {
            const buttons = document.querySelectorAll(`.question:nth-child(${questionIndex + 1}) .option-btn`);
            buttons.forEach(btn => {
                if (btn.textContent === option) {
                    btn.classList.toggle('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        function skipQuestion(index) {
            const question = document.querySelectorAll('.question')[index];
            question.style.opacity = '0.5';
        }

        async function generateLight() {
            const selectedOptions = Array.from(document.querySelectorAll('.option-btn.selected'))
                .map(btn => btn.textContent);

            document.getElementById('questionsContainer').innerHTML = '<div class="loading">Creating light design...</div>';

            try {
                const prompt = 'Design kreativt lys til "' + currentSong.input + '". \n' +
                'Brugerens pr√¶ferencer: ' + (selectedOptions.join(', ') || 'ingen specifikke') + '\n\n' +
                'Lav et lysdesign med 6 zoner: front_right, front_left, mid_right, mid_left, back_right, back_left.\n' +
                'Hver zone kan have: color (hex), intensity (0-255), effect (none/strobe/pulse).\n\n' +
                'Lav ogs√• en sangstruktur med 4-6 dele (f.eks. intro, verse, chorus, bridge, outro).\n\n' +
                'Returner KUN JSON:\n' +
                '{\n' +
                '  "structure": ["intro", "verse", "chorus", "verse", "chorus", "outro"],\n' +
                '  "parts": {\n' +
                '    "intro": {\n' +
                '      "zones": {\n' +
                '        "front_right": {"color": "#hex", "intensity": 0-255, "effect": "none"}\n' +
                '      },\n' +
                '      "description": "kort beskrivelse"\n' +
                '    }\n' +
                '  }\n' +
                '}';

                const content = await callAI(prompt);
                console.log('ü§ñ AI Raw Response:', content);
                
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                console.log('üîç JSON Match:', jsonMatch);
                
                if (jsonMatch) {
                    try {
                        currentLight = JSON.parse(jsonMatch[0]);
                        console.log('‚úÖ Parsed Light Design:', currentLight);
                        currentSong.lightDesign = currentLight;
                        displayLightPreview();
                    } catch (parseError) {
                        console.error('‚ùå JSON Parse Error:', parseError);
                        console.error('Raw JSON that failed:', jsonMatch[0]);
                        showStatus('Error: AI returned invalid JSON format');
                    }
                } else {
                    console.error('‚ùå No JSON found in response');
                    console.error('Full response:', content);
                    showStatus('Error: No JSON found in AI response');
                }
            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error generating light design: ${error.message}`);
            }
        }

        function displayLightPreview() {
            document.getElementById('questionsContainer').style.display = 'none';
            const preview = document.getElementById('lightPreview');
            preview.classList.add('active');
            
            // Render DMX zones for first part
            const firstPart = currentLight.structure[0];
            renderDMXZones(currentLight.parts[firstPart].zones);
        }

        function renderDMXZones(zones) {
            const container = document.getElementById('dmxZones');
            const zoneOrder = ['back_left', 'back_right', 'mid_left', 'mid_right', 'front_left', 'front_right'];
            
            container.innerHTML = zoneOrder.map(zoneName => {
                const zone = zones[zoneName] || { color: '#000000', intensity: 0 };
                return `
                    <div class="zone" style="background-color: ${zone.color}${Math.round(zone.intensity/255*100).toString(16).padStart(2, '0')}">
                        <span class="zone-label">${zoneName.replace('_', ' ').toUpperCase()}</span>
                    </div>
                `;
            }).join('');
        }

        async function testLight() {
            if (!currentLight) return;
            
            const firstPart = currentLight.structure[0];
            await sendDMXData(currentLight.parts[firstPart].zones);
            showStatus('Light sent to DMX controller');
        }

        async function refineLight() {
            const feedback = document.getElementById('feedbackInput').value.trim();
            if (!feedback) return;

            document.getElementById('lightPreview').innerHTML = '<div class="loading">Refining design...</div>';

            try {
                const prompt = `Nuv√¶rende lysdesign:
${JSON.stringify(currentLight, null, 2)}

Brugerens feedback: "${feedback}"

Juster lysdesignet baseret p√• feedback. Behold struktur format.
Returner KUN opdateret JSON.`;

                const content = await callAI(prompt);
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                
                if (jsonMatch) {
                    currentLight = JSON.parse(jsonMatch[0]);
                    currentSong.lightDesign = currentLight;
                    document.getElementById('feedbackInput').value = '';
                    displayLightPreview();
                }
            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error refining light: ${error.message}`);
            }
        }

        function saveLight() {
            if (!currentLight || !currentSong) return;

            const song = {
                id: Date.now(),
                title: currentSong.title,
                input: currentSong.input,
                lightDesign: currentLight,
                createdAt: new Date().toISOString()
            };

            savedSongs.push(song);
            localStorage.setItem('savedSongs', JSON.stringify(savedSongs));
            
            showStatus('Light design saved!');
            setTimeout(() => showSongList(), 1000);
        }

        // Song List
        function renderSongList() {
            const container = document.getElementById('songsContainer');
            
            if (savedSongs.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üí°</div>
                        <p>No saved songs yet</p>
                        <p style="font-size: 0.85rem; margin-top: 0.5rem;">Create your first light design</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = savedSongs.map(song => `
                <div class="song-item ${activeSongId === song.id ? 'active' : ''}" onclick="toggleSong(${song.id})">
                    <div class="song-title">${song.title}</div>
                    <div class="song-meta">Created ${new Date(song.createdAt).toLocaleDateString()}</div>
                    <div class="song-structure">
                        ${song.lightDesign.structure.map((part, index) => `
                            <div class="structure-part ${activePartIndex === index && activeSongId === song.id ? 'active' : ''}" 
                                 onclick="event.stopPropagation(); activatePart(${song.id}, ${index})">
                                ${part}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        function toggleSong(songId) {
            if (activeSongId === songId) {
                activeSongId = null;
                activePartIndex = 0;
            } else {
                activeSongId = songId;
                activePartIndex = 0;
                const song = savedSongs.find(s => s.id === songId);
                if (song) {
                    activatePart(songId, 0);
                }
            }
            renderSongList();
        }

        async function activatePart(songId, partIndex) {
            activePartIndex = partIndex;
            const song = savedSongs.find(s => s.id === songId);
            if (!song) return;

            const partName = song.lightDesign.structure[partIndex];
            const zones = song.lightDesign.parts[partName].zones;
            
            await sendDMXData(zones);
            renderSongList();
        }

        // DMX Communication
        async function sendDMXData(zones) {
            if (!settings.espIp) {
                showStatus('Please set ESP8266 IP address in settings');
                return;
            }

            // Convert zones to DMX channels
            const dmxData = zonesToDMX(zones);
            
            try {
                await fetch(`http://${settings.espIp}/dmx`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ channels: dmxData })
                });
            } catch (error) {
                console.error('DMX send error:', error);
                showStatus('Could not reach DMX controller');
            }
        }

        function zonesToDMX(zones) {
            const dmxChannels = new Array(512).fill(0);
            
            if (!dmxConfig || !dmxConfig.dmx_config) {
                console.warn('No DMX config, using basic mapping');
                return basicZonesToDMX(zones);
            }

            Object.entries(zones).forEach(([zoneName, zoneData]) => {
                const zoneConfig = dmxConfig.dmx_config.zones[zoneName];
                if (!zoneConfig || !zoneConfig.fixtures) return;

                zoneConfig.fixtures.forEach(fixture => {
                    const channelMap = fixture.channel_map;
                    const color = hexToRGB(zoneData.color);
                    
                    // Set RGB channels
                    if (channelMap.red) dmxChannels[channelMap.red - 1] = color.r;
                    if (channelMap.green) dmxChannels[channelMap.green - 1] = color.g;
                    if (channelMap.blue) dmxChannels[channelMap.blue - 1] = color.b;
                    
                    // Set dimmer/intensity
                    if (channelMap.dimmer) {
                        dmxChannels[channelMap.dimmer - 1] = zoneData.intensity || 0;
                    }
                    
                    // Set effects
                    if (zoneData.effect === 'strobe' && channelMap.strobe) {
                        dmxChannels[channelMap.strobe - 1] = 200;
                    } else if (channelMap.strobe) {
                        dmxChannels[channelMap.strobe - 1] = 0;
                    }

                    // White channel for RGBW
                    if (channelMap.white && zoneData.white) {
                        dmxChannels[channelMap.white - 1] = zoneData.white;
                    }
                });
            });

            return dmxChannels;
        }

        function basicZonesToDMX(zones) {
            // Fallback basic mapping
            const dmxChannels = new Array(512).fill(0);
            
            const zoneChannelMap = {
                'front_right': { start: 1, channels: 7 },
                'front_left': { start: 8, channels: 7 },
                'mid_right': { start: 15, channels: 7 },
                'mid_left': { start: 22, channels: 7 },
                'back_right': { start: 29, channels: 7 },
                'back_left': { start: 36, channels: 7 }
            };

            Object.entries(zones).forEach(([zoneName, zoneData]) => {
                const mapping = zoneChannelMap[zoneName];
                if (!mapping) return;

                const { start } = mapping;
                const color = hexToRGB(zoneData.color);
                
                dmxChannels[start - 1] = color.r;
                dmxChannels[start] = color.g;
                dmxChannels[start + 1] = color.b;
                dmxChannels[start + 2] = zoneData.intensity;
                
                if (zoneData.effect === 'strobe') {
                    dmxChannels[start + 3] = 200;
                }
            });

            return dmxChannels;
        }

        function hexToRGB(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Touch/Swipe handling for live control
        let touchStartX = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', (e) => {
            if (!activeSongId) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > 50) {
                const song = savedSongs.find(s => s.id === activeSongId);
                if (!song) return;
                
                if (diff > 0 && activePartIndex < song.lightDesign.structure.length - 1) {
                    // Swipe left - next part
                    activatePart(activeSongId, activePartIndex + 1);
                } else if (diff < 0 && activePartIndex > 0) {
                    // Swipe right - previous part
                    activatePart(activeSongId, activePartIndex - 1);
                }
            }
        });

        // Status messages
        function showStatus(message) {
            const existing = document.querySelector('.status-message');
            if (existing) existing.remove();

            const status = document.createElement('div');
            status.className = 'status-message';
            status.textContent = message;
            document.querySelector('.app-container').appendChild(status);

            setTimeout(() => status.remove(), 3000);
        }
    </script>
</body>
</html>
